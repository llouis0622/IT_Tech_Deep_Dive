# 모든 개발자를 위한 HTTP 웹 기본 지식

## 1. 인터넷 네트워크

### 1. 인터넷 통신
- 클라이언트, 서버 연결
  - 물리적인 선 연결
  - 인터넷 망 연결

### 2. IP(인터넷 프로토콜)
- IP 주소 부여 -> 클라이언트, 서버 둘 다
- 지정한 IP 주소에 데이터 전달
- 패킷(Packet)이라는 통신 단위로 데이터 전달
- IP 패킷 정보 : 출발지 IP, 목적지 IP, 기타 등
- 클라이언트 패킷 전달 <-> 서버 패킷 전달
- IP 프로토콜의 한계
  - 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
  - 비신뢰성 : 중간에 패킷이 사라짐 or 패킷이 순서대로 안 옴
  - 프로그램 구분 : 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 때

### 3. TCP, UDP
- 인터넷 프로토콜 스택 4계층 
  - 애플리케이션 계층 - HTTP, FTP
  - 전송 계층 - TCP, UDP
  - 인터넷 계층 - IP
  - 네트워크 인터페이스 계층
- TCP 패킷 정보 : 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등
- TCP 특징
  - 전송 제어 프로토콜(Transmission Control Protocol)
  - 연결 지향 - TCP 3way Handshake(가상 연결)
  - 데이터 전달 보증
  - 순서 보장
  - 신뢰할 수 있는 프로토콜
  - 현재는 대부분 TCP 사용
- TCP 3way Handshake : SYN -> SYN + ACK -> ACK -> 데이터 전송
- UDP 특징
  - 사용자 데이터그램 프로토콜(User Datagram Protocol)
  - 하얀 도화지에 비유(기능 거의 없음)
  - 연결 지향 X - TCP 3way Handshake X
  - 데이터 전달 보증 X
  - 순서 보장 X
  - 데이터 전달 및 순서가 보장되지 않음 but 단순하고 빠름
  - IP와 거의 동일 : PORT 체크섬 정도만 추가
  - 애플리케이션에서 추가 작업 필요

### 4. PORT
- 같은 IP 내에서 프로세스 구분 가능
- 0 ~ 65535 : 할당 가능
- 0 ~ 1023 : 잘 알려진 포트, 사용하지 않는 것이 좋음
  - FTP : 20, 21
  - TELNET : 23
  - HTTP : 80
  - HTTPS : 443

### 5. DNS
- IP
  - 기억하기 어려움
  - 변경 가능성 존재
- DNS(Domain Name System) : 전화번호부, 도메인 명을 IP 주소로 변환

## 2. URI와 웹 브라우저 요청 흐름

### 1. URI
- Uniform Resource Identifier
  - Uniform : 리소스 식별하는 통일된 방식
  - Resource : 자원, URI로 식별할 수 있는 모든 것
  - Identifier : 다른 항목과 구분하는 데 필요한 정보
- URL, URN
  - URL(Uniform Resource Locator) : 리소스가 있는 위치 지정
  - URN(Uniform Resource Name) : 리소스에 이름 부여
  - 위치는 변할 수 있지만, 이름은 변하지 않음
  - URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음
- 로케이터(Locator), 이름(Name) 또는 둘 다 추가로 분류될 수 있음
- URL 전체 문법
  - `scheme://[userinfo@]host[:port][/path][?query][#fragment]`
  - scheme
    - 주로 프로토콜 사용
    - 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
    - http -> 80 포트, https -> 443 포트 주로 사용
    - https -> http + 보안
  - userinfo
    - URL에 사용자 정보 포함해서 인증
    - 거의 사용하지 않음
  - host
    - 호스트명
    - 도메인명 또는 IP 주소를 직접 사용가능
  - PORT
    - 포트, 접속 포트
    - 일반적으로 생략
  - path
    - 리소스 경로, 계층적 구조
  - query
    - key=value 형태
    - `?`로 시작, `&`로 추가 가능
    - query parameter, query string 등으로 불림
    - 웹 서버에 제공하는 파라미터, 문자 형태
  - fragment
    - html 내부 북마크 등에 사용
    - 서버에 전송하는 정보 X

### 2. 웹 브라우저 요청 흐름
- DNS 조회 -> HTTP 요청 메시지 생성

## 3. HTTP 기본

### 1. 모든 것이 HTTP
- HyperText Transfer Protocol
  - HTML, TEXT
  - Image, 음성, 영상, 파일
  - JSON, XML(API)
  - 거의 모든 형태의 데이터 전송 가능
  - 서버간에 데이터를 주고 받을 때에도 대부분 HTTP 사용
- HTTP 역사
  - 1991년 : HTTP/0.9, GET 메서드만 지원, HTTP 헤더 X
  - 1996년 : HTTP/1.0, 메서드, 헤더 추가
  - 1997년 : HTTP/1.1, 가장 많이 사용, 우리에게 가장 중요한 버전
  - 2015년 : HTTP/2, 성능 개선
  - HTTP/3 진행중 : TCP 대신에 UDP 사용, 성능 개선
- 기반 프로토콜
  - TCP : HTTP/1.1, HTTP/2
  - UDP : HTTP/3
- HTTP 특징
  - 클라이언트 서버 구조 
  - 무상태 프로토콜, 비연결성
  - HTTP 메시지
  - 단순함, 확장 가능

### 2. 클라이언트 서버 구조
- Request Response 구조
- 클라이언트는 서버에 요청을 보내고 응답 대기
- 서버가 요청에 대한 결과를 만들어서 응답

### 3. Stateful, Stateless
- 서버가 클라이언트의 상태 보존 X
- 서버 확장성 높음 but 클라이언트가 추가 데이터 전송
- Stateful : 상태 유지, 항상 같은 서버가 유지되어야 함
- Stateless : 무상태 -> 응답 서버 쉽게 변경 가능, 아무 서버나 호출 가능
  - 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 존재
  - 상태 유지는 최소한만 사용

### 4. 비연결성(Connectionless)
- HTTP는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 서버 자원을 매우 효율적으로 사용 가능
- TCP/IP 연결을 새로 맺어야 함 -> 3way Handshake 시간 추가
- 웹 브라우저로 사이트 요청 -> HTML 뿐만 아니라 JS, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드
- HTTP 지속 연결로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화

### 5. HTTP 메시지
- HTTP 메시지 구조 : 시작 라인, 헤더, 공백 라인(CRLF), Message Body
- 시작 라인
  - 요청 메시지
  - start-line : request-line/status-line
  - request-line : method SP request-target SP HTTP-version CRLF
  - HTTP 메서드(GET 조회)
  - 요청 대상
  - HTTP version
  - GET : 리소스 조회
  - POST : 요청 내역 처리
  - absolute-path[?query] : 절대경로
- HTTP 상태 코드
  - 200 : 성공
  - 400 : 클라이언트 요청 오류
  - 500 : 서버 내부 오류
  - 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글
- HTTP 헤더
  - header-field = field-name:OWS(띄어쓰기 허용) field-value OWS
  - HTTP 전송에 필요한 모든 부가정보
  - 표준 헤더가 너무 많음
  - 필요시 임의의 헤더 추가 가능
- HTTP 메시지 바디
  - 실제 전송할 데이터
  - HTML 문서, 이미지, 영상, JSON 등등 Byte로 표현할 수 있는 모든 데이터 전송 가능

## 4. HTTP 메서드

### 1. HTTP API를 만들어보자
- API URI 설계
  - 회원 목록 조회 : /read-member-list
  - 회원 조회 : /read-member-by-id
  - 회원 등록 : /create-member
  - 회원 수정 : /update-member
  - 회원 삭제 : /delete-member
- API URI 고민
  - 리소스의 의미 : 개념 자체
  - 리소스를 어떻게 식별하는가 -> 리소스를 URI에 매핑
- API URI 설계
  - 회원 목록 조회 : /members
  - 회원 조회 : /members/{id}
  - 회원 등록 : /members/{id}
  - 회원 수정 : /members/{id}
  - 회원 삭제 : /members/{id}
  - URI는 리소스만 식별 -> 리소스와 해당 리소스를 대상으로 하는 행위 분리

### 2. HTTP 메서드 - GET, POST
- HTTP 메서드 종류
  - GET : 리소스 조회
  - POST : 요청 데이터 처리, 주로 등록에 사용
  - PUT : 리소스 대체, 해당 리소스가 없으면 생성
  - PATCH : 리소스 부분 변경
  - DELETE : 리소스 삭제
  - HEAD : GET과 동일, 메시지 부분을 제외하고 상태 줄과 헤더만 반환
  - OPTIONS : 대상 리소스에 대한 통신 가능 옵션 설명
  - CONNECT : 대상 리소스로 식별되는 서버에 대한 터널 설정
  - TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행
- GET
  - 리소스 조회
  - 서버에 전달하고 싶은 데이터 query를 통해 전달
  - 메시지 바디를 사용해서 데이터 전달 가능 but 지원하지 않는 곳이 많음 -> 권장 X
- POST
  - 요청 데이터 처리
  - 메시지 바디를 통해 서버로 요청 데이터 전달
  - 서버는 요청 데이터 처리
  - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행
  - 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
  - 다른 메서드로 처리하기 애매한 경우 사용

### 3. HTTP 메서드 - PUT, PATCH, DELETE
- PUT
  - 리소스 대체 : 리소스가 있으면 대체, 없으면 생성
  - 클라이언트가 리소스 식별 : 리소스 위치를 알고 URI 지정
- PATCH : 리소스 부분 변경
- DELETE : 리소스 제거

### 4. HTTP 메서드 속성
- 안전(Safe Methods) : 호출해도 리소스를 변경하지 않음
- 멱등(Idempotent Methods) : 모든 호출의 결과가 동일
- 캐시가능(Casheable Methods) : 응답 결과 리소스를 캐시헤서 사용해도 되는가
- GET : 안전, 멱등, 캐시가능
- HEAD : 안전, 멱등, 캐시가능
- POST : 캐시가능
- PUT : 멱등
- DELETE : 멱등
- CONNECT : X
- OPTIONS : 안전, 멱등
- TRACE : 안전, 멱등
- PATCH : 캐시가능

## 5. HTTP 메서드 활용

### 1. 클라이언트에서 서버로 데이터 전송
- 쿼리 파라미터를 통한 데이터 전송
  - GET
  - 주로 정렬 필터(검색어)
- 메시지 바디를 통한 데이터 전송
  - POST, PUT, PATCH
  - 회원 가입, 상품 주문, 리소스 등록, 리소스 변경
- 정적 데이터 조회
  - 이미지, 정적 텍스트 문서
  - 조회는 GET 사용
  - 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능
- 동적 데이터 조회
  - 주로 검색, 게시판 목록에서 정렬 필터(검색어)
  - 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용
  - 조회는 GET 사용
  - GET은 쿼리 파라미터 사용해서 데이터를 전달
- HTML Form을 통한 데이터 전송
  - 회원 가입, 상품 주문, 데이터 변경
  - HTML Form Submit시 POST 전송
  - Content-Type : application/x-www-form-urlencoded 사용
  - HTML Form은 GET 전송도 가능
  - Content-Type : multipart/form-data
  - GET, POST만 지원
- HTTP API를 통한 데이터 전송
  - 회원 가입, 상품 주문, 데이터 변경
  - 서버 to 서버, 앱 클라이언트, 웹 클라이언트(Ajax)
  - POST, PUT, PATCH : 메시지 바디를 통해 데이터 전송
  - GET : 조회, 쿼리 파라미터로 데이터 전달
  - Content-Type : application/json을 주로 사용(사실상 표준)

### 2. HTTP API 설계 예시
- 참고하면 좋은 URI 설계 개념
  - 문서(Document)
    - 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스)
  - 컬렉션(Collection)
    - 서버가 관리하는 리소스 디렉터리
    - 서버가 리소스의 URI를 생성하고 관리
  - 스토어(Store)
    - 클라이언트가 관리하는 자원 저장소
    - 클라이언트가 리소스의 URI를 알고 관리
  - 컨트롤러(Controller), 컨트롤 URI
    - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
    - 동사를 직접 사용

## 6. HTTP 상태코드

### 1. HTTP 상태코드 소개
- 상태 코드 : 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
- 1XX(Informational) : 요청이 수신되어 처리중
- 2XX(Successful) : 요청 정상 처리
- 3XX(Redirection) : 요청을 완료하려면 추가 행동이 필요
- 4XX(Client Error) : 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
- 5XX(Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함
- 모르는 상태 코드 등장 -> 상위 상태코드로 해석해서 처리

### 2. 2XX - 성공
- 200 : OK, 요청 성공
- 201 : Created, 요청 성공해서 새로운 리소스가 생성
- 202 : Accepted, 요청이 접수되었으나 처리가 완료되지 않음
- 204 : No Content, 서버가 요청을 성공적으로 수행헀지만, 응답 페이로드 본문에 보낼 데이터가 없음

### 3. 3XX - 리다이렉션
- 300 : Multiple Choices, 사용 안함
- 301 : Moved Permanently, 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음, 영구 리다이렉션
- 302 : Found, 리다이렉션 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음, 일시 리다이렉션
- 303 : See Other, 리다이렉트 시 요청 메서드가 GET으로 변경, 일시 리다이렉션
- 304 : Not Modified, 캐시 목적, 리소스가 수정되지 않았음을 알림
- 307 : Temporary Redirect, 리다이렉션 시 요청 메서드와 본문 유지, 일시 리다이렉션
- 308 : Permanent Redirect, 리다이렉트 시 요청 메서드와 본문 유지, 영구 리다이렉션
- 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동
- 일시 리다이렉션 : 일시적인 변경
- 특수 리다이렉션 : 결과 대신 캐시를 사용

### 4. 4XX - 클라이언트 오류
- 400 : Bad Request, 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
- 401 : Unauthorized, 클라이언트가 해당 리소스에 대한 인증이 필요함
  - 인증(Authentication) : 본인이 누구인지 확인
  - 인가(Authorization) : 권한부여
- 403 : Forbidden, 서버가 요청을 이해했지만 승인을 거부함
- 404 : Not Found, 요청 리소스를 찾을 수 없음

### 5. 5XX - 서버 오류
- 500 : Internal Server Error, 서버 문제로 오류 발생
- 503 : Service Unavailable, 서비스 이용 불가

## 7. HTTP 헤더 1 - 일반 헤더

### 1. HTTP 헤더 개요
- HTTP 전송에 필요한 모든 부가정보
- 표준 헤더가 너무 많음
- 필요시 임의의 헤더 추가 가능
- General 헤더 : 메세지 전체에 적용되는 정보
- Request 헤더 : 요청 정보
- Response 헤더 : 응답 정보
- Entity 헤더 : 엔티티 바디 정보
- HTTP Body
  - 메시지 본문은 엔티티 본문을 전달하는데 사용
  - 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터
  - 엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보 제공
  - 엔티티 -> 표현(Representation) : Representation Metadata + Representation Data

### 2. 표현
- Content-Type : 표현 데이터의 형식, 미디어 타입, 문자 인코딩
- Content-Encoding : 표현 데이터의 압축 방식
  - 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
  - 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
- Content-Language : 표현 데이터의 자연 언어
- Content-Length : 표현 데이터의 길이, 바이트 단위

### 3. 콘텐츠 협상
- 클라이언트가 선호하는 표현 요청
- Accept : 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset : 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
- Accept-Language : 클라이언트가 선호하는 자연 언어
- 협상과 우선순위
  - Quality Values : 0 ~ 1, 클수록 높은 우선순위, 생략하면 1
  - 구체적인 것이 우선
  - 구체적인 것을 기준으로 미디어 타입을 맞춤

### 4. 전송 방식
- 단순 전송 : Content-Length
- 압축 전송 : Content-Encoding
- 분할 전송 : Transfer-Encoding
- 범위 전송 : Range, Content-Range

### 5. 일반 정보
- From : 유저 에이전트의 이메일 정보
  - 일반적으로 잘 사용되지 않음
  - 검색 엔진 같은 곳에서 주로 사용
  - 요청에서 사용
- Referer : 이전 웹 페이지 주소
  - 유입 경로 분석 가능
  - 요청에서 사용
- User-Agent : 유저 에이전트 애플리케이션 정보
  - 클라이언트의 애플리케이션 정보
  - 통계 정보
  - 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
  - 요청에서 사용
- Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보
  - 응답에서 사용
- Date : 메시지가 생성된 날짜
  - 응답에서 사용

### 6. 특별한 정보
- Host : 요청한 호스트 정보(도메인)
  - 요청에서 사용, 필수
  - 하나의 서버가 여러 도메인을 처리해야 할 때
  - 하나의 IP 주소에 여러 도메인이 적용되어 있을 때
- Location : 페이지 리다이렉션
  - 201, 3XX
- Allow : 허용 가능한 HTTP 메서드
  - 405에서 응답에 포함
  - GET, HEAD, PUT
- Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  - 503 : 서비스가 언제까지 불능인지 알려줄 수 있음

### 7. 인증
- Authorization : 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의, 401 응답과 함께 사용

### 8. 쿠키
- Set-Cookie : 서버에서 클라이언트로 쿠키 전달
- Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
- 사용자 로그인 세션 관리
- 광고 정보 트래킹
- 쿠키 정보는 항상 서버에 전송 -> 네트워크 트래픽 추가 유발, 최소한의 정보만 사용
- 생명주기
  - expires : 만료일이 되면 쿠키 삭제
  - max-age : 0이나 음수를 지정하면 쿠키 삭제
  - 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지
  - 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지
- 도메인
  - 명시 : 명시한 문서 기준 도메인 + 서브 도메인 포함
  - 생략 : 현재 문서 기준 도메인만 적용
- 경로
  - 경로를 포함한 하위 경루 페이지만 쿠키 접근
  - 일반적으로 `path=/` 루트로 지정
- 보안
  - Secure : 쿠키는 http, https를 구분하지 않고 전송, 적용시 https인 경우에만 전송
  - HttpOnly : XSS 공격 방지, 자바스크립트에서 접근 불가, http 전송에만 사용
  - SameSite : XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

## 8. HTTP 헤더 2 - 캐시와 조건부 요청

### 1. 캐시 기본 동작
- 캐시가 없을 때
  - 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 함
  - 인터넷 네트워크는 매우 느리고 비쌈
  - 브라우저 로딩 속도가 느림
  - 느린 사용자 경험
- 캐시 적용
  - 캐시 덕분에 가능 시간동안 네트워크를 사용하지 않아도 됨
  - 비싼 네트워크 사용량 감소 가능
  - 브라우저 로딩 속도가 매우 빠름
  - 빠른 사용자 경험
- 캐시 시간 초과
  - 서버를 통해 데이터를 다시 조회, 캐시 갱신
  - 다시 네트워크 다운로드 발생

### 2. 검증 헤더와 조건부 요청 1
- 캐시 유효 시간이 초괴해도 서버의 데이터가 갱신되지 않음
- 304 + 헤더 메타 정보만 응답
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드

### 3. 검증 헤더와 조건부 요청 2
- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - Last-Modified, ETag
- 조건부 요청 헤더
  - 검증 헤더로 조건에 따른 분기
  - If-Modified-Since : Last-Modified 사용
  - If-None-Match : ETag 사용
  - 조건이 만족하면 200 OK
  - 조건이 만족하지 않으면 304 Not Modified
- 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
- 캐시 제어 로직을 서버에서 완전히 관리
- 클라이언트는 단순히 이 값을 서버에 제공

### 4. 캐시와 조건부 요청 헤더
- Cache-Control : 캐시 제어
  - max-age : 캐시 유효 시간, 초 단위
  - no-cache : 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
  - no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨
- Pragma : 캐시 제어(하위 호환)
  - no-cache
  - HTTP 1.0 하위 호환
- Expires : 캐시 유효 기간(하위 호환)
  - expires
  - 캐시 만료일을 정확한 날짜로 지정
  - HTTP 1.0부터 사용

### 5. 프록시 캐시
- public : 응답이 public 캐시에 저장되어도 됨
- private : 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함
- s-maxage : 프록시 캐시에만 적용되는 max-age
- Age:60 : 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간

### 6. 캐시 무효화
- must-revalidate
  - 캐시 만료 후 최초 조회 시 원 서버에 검증
  - 원 서버 접근 실패 시 반드시 오류가 발생해야함
  - 캐시 유효 시간이라면 캐시 사용